trash_speed = 1
pause_flag = 0
game_finished = false

function update_scroll_bar(self)
	gui.animate(self.glass_node, "color.w", vmath.vector4(1, 1, 1, 0.35), gui.EASING_OUT, 0)
	gui.animate(self.paper_node, "color.w", vmath.vector4(1, 1, 1, 0), gui.EASING_OUT, 0)
	gui.animate(self.plasmet_node, "color.w", vmath.vector4(1, 1, 1, 0), gui.EASING_OUT, 0)
	gui.animate(self.organic_node, "color.w", vmath.vector4(1, 1, 1, 0), gui.EASING_OUT, 0)
	gui.animate(self.mixed_node, "color.w", vmath.vector4(1, 1, 1, 0), gui.EASING_OUT, 0)
	if level > 1 then
		gui.animate(self.paper_node, "color.w", vmath.vector4(1, 1, 1, 0.35), gui.EASING_OUT, 0)
	end
	if level > 2 then
		gui.animate(self.plasmet_node, "color.w", vmath.vector4(1, 1, 1, 0.35), gui.EASING_OUT, 0)
	end
	if level > 3 then
		gui.animate(self.organic_node, "color.w", vmath.vector4(1, 1, 1, 0.35), gui.EASING_OUT, 0)
	end
	if level > 4 then
		gui.animate(self.mixed_node, "color.w", vmath.vector4(1, 1, 1, 0.35), gui.EASING_OUT, 0)
	end
	
	if actual_can == 1 then
		gui.animate(self.glass_node, "color.w", vmath.vector4(1, 1, 1, 1), gui.EASING_OUT, 0.5)
	elseif actual_can == 2 then
		gui.animate(self.paper_node, "color.w", vmath.vector4(1, 1, 1, 1), gui.EASING_OUT, 0.5)
	elseif actual_can == 3 then
		gui.animate(self.plasmet_node, "color.w", vmath.vector4(1, 1, 1, 1), gui.EASING_OUT, 0.5)
	elseif actual_can == 4 then
		gui.animate(self.organic_node, "color.w", vmath.vector4(1, 1, 1, 1), gui.EASING_OUT, 0.5)
	elseif actual_can == 5 then
		gui.animate(self.mixed_node, "color.w", vmath.vector4(1, 1, 1, 1), gui.EASING_OUT, 0.5)
	end
end

function init(self)
	local ui_left = gui.get_node("ui_left") 
	local ui_center = gui.get_node("ui_center") 
	local ui_help = gui.get_node("ui_right") 
	msg.post(".", "acquire_input_focus")
	
	self.score = 0
	self.lives = 5
	pause_flag = 0
	end_game_flag = false
	self.score_node = gui.get_node("score_text")
	self.lives_node = gui.get_node("lives_text")
	self.level_node = gui.get_node("level_text")
	self.glass_node = gui.get_node("glass_prev")
	self.paper_node = gui.get_node("paper_prev")
	self.plasmet_node = gui.get_node("plasmet_prev")
	self.organic_node = gui.get_node("organic_prev")
	self.mixed_node = gui.get_node("mixed_prev")

	if controls_help == true then
		msg.post("help_controls#gui", "controls_on")
		gui.set_enabled(ui_left, false)
		gui.set_enabled(ui_center, false)
		gui.set_enabled(ui_help, false)
		gui.animate(self.glass_node, "color.w", vmath.vector4(1, 1, 1, 0), gui.EASING_OUT, 0)
		gui.animate(self.paper_node, "color.w", vmath.vector4(1, 1, 1, 0), gui.EASING_OUT, 0)
		gui.animate(self.plasmet_node, "color.w", vmath.vector4(1, 1, 1, 0), gui.EASING_OUT, 0)
		gui.animate(self.organic_node, "color.w", vmath.vector4(1, 1, 1, 0), gui.EASING_OUT, 0)
		gui.animate(self.mixed_node, "color.w", vmath.vector4(1, 1, 1, 0), gui.EASING_OUT, 0)
	else
		gui.set_enabled(ui_left, true)
		gui.set_enabled(ui_center, true)
		gui.set_enabled(ui_help, true)
		update_scroll_bar(self)
	end
	
end

local function scale_down(self, node)
	local s = 1.0
	gui.animate(node, gui.PROP_SCALE, vmath.vector4(s, s, s, 0), gui.EASING_OUT, 0.05)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("add_score") then
		local s = 1.2
		self.score = self.score + message.amount
		gui.set_text(self.score_node, tostring(self.score))
		gui.animate(self.score_node, gui.PROP_SCALE, vmath.vector4(s, s, s, 0), gui.EASING_OUT, 0.1, 0.0, scale_down)
		if self.score >= (level/0.1)^2 then
			if (sound_effect_flag == true) then
				sound.play("gui_sound#sound_level_up", {delay = 0, gain = 1, pan = -1.0, speed = 1})
			end
			level = level + 1
			print("Level: ",tostring(level));
			gui.set_text(self.level_node, tostring(level))
			gui.animate(self.level_node, gui.PROP_SCALE, vmath.vector4(s, s, s, 0), gui.EASING_OUT, 0.1, 0.0, scale_down)
			update_scroll_bar(self)
			if level > 5 then
				trash_speed = trash_speed * 1.1
				print("Trash speed: ",tostring(trash_speed));
				-- frequency = frequency + (0.35/level)
				frequency = frequency * 1.1
				print("Trash freq: ", tostring(frequency));
			end
		end
	end
	if message_id == hash("add_live") then
		local s = 1.2
		self.lives = self.lives + message.amount
		gui.set_text(self.lives_node, tostring(self.lives))
		gui.animate(self.lives_node, gui.PROP_SCALE, vmath.vector4(s, s, s, 0), gui.EASING_OUT, 0.1, 0.0, scale_down)
		if self.lives == 0 then
			msg.post("end_game#gui", "player_lost", {final_score = self.score})
		end
	end
	if message_id == hash("change_can") then
		update_scroll_bar(self)
	end
	
	if message_id == hash("hide_menu") then
		local help_node = gui.get_node("help")
		gui.set_enabled(help_node, false)
	end

	if message_id == hash("controls_off") then
		local ui_left = gui.get_node("ui_left") 
		local ui_center = gui.get_node("ui_center") 
		local ui_help = gui.get_node("ui_right") 
		gui.set_enabled(ui_left, true)
		gui.set_enabled(ui_center, true)
		gui.set_enabled(ui_help, true)
		update_scroll_bar(self)
		controls_help = false
		pause_flag = 0
	end
end

function on_input(self, action_id, action)
	if(action_id == hash("touch") and action.pressed == true) then
		local left_node = gui.get_node("touch_left")
		local right_node = gui.get_node("touch_right")
		local help_node = gui.get_node("help")
		if(gui.pick_node(help_node, action.x, action.y)) then
			if game_finished == false then
				if pause_flag == 1 then
					if (sound_effect_flag == true) then
						sound.play("gui_sound#sound_ui_click", {delay = 0, gain = 1, pan = -1.0, speed = 1})
					end
					msg.post("help_pause#gui", "unpause")
				else
					if (sound_effect_flag == true) then
						sound.play("gui_sound#sound_ui_click", {delay = 0, gain = 1, pan = -1.0, speed = 1})
					end
					msg.post("help_pause#gui", "pause")
				end
			end
		elseif(gui.pick_node(left_node, action.x, action.y)) then
			msg.post("paper-trashcan", "CAN_CHANGE_LEFT")
		elseif(gui.pick_node(right_node, action.x, action.y)) then
			msg.post("paper-trashcan", "CAN_CHANGE_RIGHT")
		end
	end
	
end
