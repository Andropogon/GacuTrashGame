local flow = require "ludobits.m.flow"
local leaderboard = require "example.playfab.leaderboard"
local navigate = require "example.navigate"

trash_speed = 3.3
pause_flag = 0
game_finished = false
unlocked_items_glass = {}
tg = {}
table.insert(unlocked_items_glass, "#glass-factory0")
table.insert(tg, 0 )
unlocked_items_paper = {}
tpap = {}
unlocked_items_plastic = {}
tpla = {}
unlocked_items_organic = {}
to = {}
unlocked_items_mixed = {}
tm = {}
counter_t = {}
counter_t[0] = 1
counter_t[1] = 0
counter_t[2] = 0
counter_t[3] = 0
counter_t[4] = 0
function update_scroll_bar(self)
	gui.animate(self.glass_node, "color.w", vmath.vector4(1, 1, 1, 0.35), gui.EASING_OUT, 0)
	gui.animate(self.paper_node, "color.w", vmath.vector4(1, 1, 1, 0), gui.EASING_OUT, 0)
	gui.animate(self.plasmet_node, "color.w", vmath.vector4(1, 1, 1, 0), gui.EASING_OUT, 0)
	gui.animate(self.organic_node, "color.w", vmath.vector4(1, 1, 1, 0), gui.EASING_OUT, 0)
	gui.animate(self.mixed_node, "color.w", vmath.vector4(1, 1, 1, 0), gui.EASING_OUT, 0)
	if level > 1 then
		gui.animate(self.paper_node, "color.w", vmath.vector4(1, 1, 1, 0.35), gui.EASING_OUT, 0)
	end
	if level > 2 then
		gui.animate(self.plasmet_node, "color.w", vmath.vector4(1, 1, 1, 0.35), gui.EASING_OUT, 0)
	end
	if level > 3 then
		gui.animate(self.organic_node, "color.w", vmath.vector4(1, 1, 1, 0.35), gui.EASING_OUT, 0)
	end
	if level > 4 then
		gui.animate(self.mixed_node, "color.w", vmath.vector4(1, 1, 1, 0.35), gui.EASING_OUT, 0)
	end
	
	if actual_can == 1 then
		gui.animate(self.glass_node, "color.w", vmath.vector4(1, 1, 1, 1), gui.EASING_OUT, 0.5)
	elseif actual_can == 2 then
		gui.animate(self.paper_node, "color.w", vmath.vector4(1, 1, 1, 1), gui.EASING_OUT, 0.5)
	elseif actual_can == 3 then
		gui.animate(self.plasmet_node, "color.w", vmath.vector4(1, 1, 1, 1), gui.EASING_OUT, 0.5)
	elseif actual_can == 4 then
		gui.animate(self.organic_node, "color.w", vmath.vector4(1, 1, 1, 1), gui.EASING_OUT, 0.5)
	elseif actual_can == 5 then
		gui.animate(self.mixed_node, "color.w", vmath.vector4(1, 1, 1, 1), gui.EASING_OUT, 0.5)
	end
end

function init(self)
	local ui_left = gui.get_node("ui_left") 
	local ui_center = gui.get_node("ui_center") 
	local ui_help = gui.get_node("ui_right") 
	msg.post(".", "acquire_input_focus")
	self.score = 0
	self.lives = 1
	pause_flag = 0
	end_game_flag = false
	self.score_node = gui.get_node("score_text")
	self.lives_node = gui.get_node("lives_text")
	self.level_node = gui.get_node("level_text")
	self.glass_node = gui.get_node("glass_prev")
	self.paper_node = gui.get_node("paper_prev")
	self.plasmet_node = gui.get_node("plasmet_prev")
	self.organic_node = gui.get_node("organic_prev")
	self.mixed_node = gui.get_node("mixed_prev")
	self.message_node = gui.get_node("message")
	gui.set_enabled(self.message_node, false)
	if controls_help == true then
		msg.post("help_controls#gui", "controls_on")
		gui.set_enabled(ui_left, false)
		gui.set_enabled(ui_center, false)
		gui.set_enabled(ui_help, false)
		gui.animate(self.glass_node, "color.w", vmath.vector4(1, 1, 1, 0), gui.EASING_OUT, 0)
		gui.animate(self.paper_node, "color.w", vmath.vector4(1, 1, 1, 0), gui.EASING_OUT, 0)
		gui.animate(self.plasmet_node, "color.w", vmath.vector4(1, 1, 1, 0), gui.EASING_OUT, 0)
		gui.animate(self.organic_node, "color.w", vmath.vector4(1, 1, 1, 0), gui.EASING_OUT, 0)
		gui.animate(self.mixed_node, "color.w", vmath.vector4(1, 1, 1, 0), gui.EASING_OUT, 0)
	else
		gui.set_enabled(ui_left, true)
		gui.set_enabled(ui_center, true)
		gui.set_enabled(ui_help, true)
		update_scroll_bar(self)
	end
end

local function scale_down(self, node)
	local s = 1.0
	gui.animate(node, gui.PROP_SCALE, vmath.vector4(s, s, s, 0), gui.EASING_OUT, 0.05)
end

math.randomseed( os.time() ) -- first, sets a seed for the pseudo-random generator

local  function my_random (t,from, to)  -- second, exclude duplicates
	local num = math.random (from, to)
	if t[num] then  num = my_random (t, from, to)   end
	t[num]=num 
	return num
end

local function show_message(self, message)
	print("show_message", message)
	flow.start(function()
		gui.set_enabled(self.message_node, true)
		gui.set_text(self.message_node, message)
		gui.set_color(self.message_node, vmath.vector4(0.5, 0, 0.5, 0))
		flow.gui_animate(self.message_node, gui.PROP_COLOR, gui.PLAYBACK_ONCE_FORWARD, vmath.vector4(0.5, 0, 0.5, 1), gui.EASING_INCUBIC, 1)
		flow.delay(2)
		flow.gui_animate(self.message_node, gui.PROP_COLOR, gui.PLAYBACK_ONCE_FORWARD, vmath.vector4(0.5, 0, 0.5, 1), gui.EASING_INCUBIC, 1)
	end)
end


function on_message(self, message_id, message, sender)
	if message_id == hash("add_score") then
		local s = 1.2
		self.score = self.score + message.amount
		gui.set_text(self.score_node, tostring(self.score))
		gui.animate(self.score_node, gui.PROP_SCALE, vmath.vector4(s, s, s, 0), gui.EASING_OUT, 0.1, 0.0, scale_down)
		if self.score >= (level/0.1)^1.95 then
			if (sound_effect_flag == true) then
				sound.play("gui_sound#sound_level_up", {delay = 0, gain = 1, pan = -1.0, speed = 1})
			end
			-- print("GLASS SIZE", table.getn(unlocked_items_glass))
			level = level + 1
			-- print("Level: ",tostring(level));
			gui.set_text(self.level_node, tostring(level))
			gui.animate(self.level_node, gui.PROP_SCALE, vmath.vector4(s, s, s, 0), gui.EASING_OUT, 0.1, 0.0, scale_down)
			update_scroll_bar(self)
			if level > 5 then
				if trash_speed < 5 then
					trash_speed = trash_speed * 1.05
				end
				print("Trash speed: ",tostring(trash_speed));
				-- frequency = frequency + (0.35/level)
				frequency = frequency * 1.1
				print("Trash freq: ", tostring(frequency));
				
				level_mod_5 = math.random(0,4)
				if level_mod_5 == 1 and counter_t[0] < 6 then
					-- Rand without repeats
					rand = my_random(tg, 1, 5)
					counter_t[0] = counter_t[0] + 1
					print("NEW LEVEL - GLASS", rand)
					print("UNIQUE RANDOM COUNTER",counter_t[0])
					table.insert(unlocked_items_glass, "#glass-factory" .. tostring(rand))
				elseif level_mod_5 == 2 and counter_t[1] < 6 then
					rand = my_random (tpap, 0, 5)
					counter_t[1] = counter_t[1] + 1
					print("NEW LEVEL - PAPER", rand)
					print("UNIQUE RANDOM COUNTER",counter_t[1])
					table.insert(unlocked_items_paper, "#paper-factory" .. tostring(rand))
				elseif level_mod_5 == 3 and counter_t[2] < 7 then
					rand = my_random (tpla, 0, 6)
					counter_t[2] = counter_t[2] + 1
					print("NEW LEVEL - PLASTIC", rand)
					print("UNIQUE RANDOM COUNTER",counter_t[2])
					table.insert(unlocked_items_plastic, "#plastic_metal-factory" .. tostring(rand))
				elseif level_mod_5 == 4 and counter_t[3] < 6 then
					rand = my_random (to, 0, 5)
					counter_t[3] = counter_t[3] + 1
					print("NEW LEVEL - ORGANIC", rand)
					print("UNIQUE RANDOM COUNTER",counter_t[3])
					table.insert(unlocked_items_organic, "#organic-factory" .. tostring(rand))
				elseif level_mod_5 == 0 and counter_t[4] < 5 then
					rand = my_random (tm, 0, 4)
					counter_t[4] = counter_t[4] + 1
					print("NEW LEVEL - MIXED", rand)
					print("UNIQUE RANDOM COUNTER",counter_t[4])
					table.insert(unlocked_items_mixed, "#mixed-factory" .. tostring(rand))
				end
			else
				level_mod_5 = level % 5
				if level_mod_5 == 1 and counter_t[0] < 6 then
					-- Rand without repeats
					rand = my_random(tg, 1, 5)
					counter_t[0] = counter_t[0] + 1
					print("NEW LEVEL - GLASS", rand)
					print("UNIQUE RANDOM COUNTER",counter_t[0])
					table.insert(unlocked_items_glass, "#glass-factory" .. tostring(rand))
				elseif level_mod_5 == 2 and counter_t[1] < 6 then
					rand = my_random (tpap, 0, 5)
					counter_t[1] = counter_t[1] + 1
					print("NEW LEVEL - PAPER", rand)
					print("UNIQUE RANDOM COUNTER",counter_t[1])
					table.insert(unlocked_items_paper, "#paper-factory" .. tostring(rand))
				elseif level_mod_5 == 3 and counter_t[2] < 7 then
					rand = my_random (tpla, 0, 6)
					counter_t[2] = counter_t[2] + 1
					print("NEW LEVEL - PLASTIC", rand)
					print("UNIQUE RANDOM COUNTER",counter_t[2])
					table.insert(unlocked_items_plastic, "#plastic_metal-factory" .. tostring(rand))
				elseif level_mod_5 == 4 and counter_t[3] < 6 then
					rand = my_random (to, 0, 5)
					counter_t[3] = counter_t[3] + 1
					print("NEW LEVEL - ORGANIC", rand)
					print("UNIQUE RANDOM COUNTER",counter_t[3])
					table.insert(unlocked_items_organic, "#organic-factory" .. tostring(rand))
				elseif level_mod_5 == 0 and counter_t[4] < 5 then
					rand = my_random (tm, 0, 4)
					counter_t[4] = counter_t[4] + 1
					print("NEW LEVEL - MIXED", rand)
					print("UNIQUE RANDOM COUNTER",counter_t[4])
					table.insert(unlocked_items_mixed, "#mixed-factory" .. tostring(rand))
				end
			end
		end
	end
	if message_id == hash("add_live") then
		local s = 1.2
		self.lives = self.lives + message.amount
		gui.set_text(self.lives_node, tostring(self.lives))
		gui.animate(self.lives_node, gui.PROP_SCALE, vmath.vector4(s, s, s, 0), gui.EASING_OUT, 0.1, 0.0, scale_down)
		if self.lives == 0 then
			show_message(self, "GAME OVER")
			sound.stop("paper-trashcan#sound")
			pause_flag = 1
			end_game_flag = true
			game_finished = true
			-- if sound_effect_flag == true then
			-- 	sound.play("gui_sound#sound_game_over", {delay = 0, gain = 1, pan = -1.0, speed = 1})
			-- 	gui.set_enabled(self.music_off_node, false)
			-- else
			-- 	gui.set_enabled(self.music_off_node, true)
			-- end
			-- msg.post("end_game#gui", "player_lost", {final_score = self.score})
			flow.start(function()
				flow.delay(3)
				-- msg.post("game:/game#hud", "game_over")
				leaderboard.update(self.score)
				leaderboard.set_last_score(self.score)
				navigate.leaderboard()
			end)
		end
	end
	if message_id == hash("change_can") then
		update_scroll_bar(self)
	end
	
	if message_id == hash("hide_menu") then
		local help_node = gui.get_node("help")
		gui.set_enabled(help_node, false)
	end

	if message_id == hash("controls_off") then
		local ui_left = gui.get_node("ui_left") 
		local ui_center = gui.get_node("ui_center") 
		local ui_help = gui.get_node("ui_right") 
		gui.set_enabled(ui_left, true)
		gui.set_enabled(ui_center, true)
		gui.set_enabled(ui_help, true)
		update_scroll_bar(self)
		controls_help = false
		pause_flag = 0
	end
end

function on_input(self, action_id, action)
	if(action_id == hash("touch") and action.pressed == true) then
		local left_node = gui.get_node("touch_left")
		local right_node = gui.get_node("touch_right")
		local help_node = gui.get_node("help")
		if(gui.pick_node(help_node, action.x, action.y)) then
			if game_finished == false then
				if pause_flag == 1 then
					if (sound_effect_flag == true) then
						sound.play("gui_sound#sound_ui_click", {delay = 0, gain = 1, pan = -1.0, speed = 1})
					end
					msg.post("help_pause#gui", "unpause")
				else
					if (sound_effect_flag == true) then
						sound.play("gui_sound#sound_ui_click", {delay = 0, gain = 1, pan = -1.0, speed = 1})
					end
					msg.post("help_pause#gui", "pause")
				end
			end
		elseif(gui.pick_node(left_node, action.x, action.y)) then
			msg.post("paper-trashcan", "CAN_CHANGE_LEFT")
		elseif(gui.pick_node(right_node, action.x, action.y)) then
			msg.post("paper-trashcan", "CAN_CHANGE_RIGHT")
		end
	end
end
	
